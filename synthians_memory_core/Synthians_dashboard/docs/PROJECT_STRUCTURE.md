
---

## **3. `docs/dashboard/PROJECT_STRUCTURE.md` (File Tree & Components)**

```markdown
# Dashboard Project Structure

This document outlines the file and directory structure of the Synthians Cognitive Dashboard project.

## File Tree Diagram

```plaintext
Synthians_dashboard/
├── client/                   # React Frontend Application
│   ├── public/
│   │   └── favicon.ico
│   ├── src/
│   │   ├── components/
│   │   │   ├── dashboard/      # Dashboard-specific complex components
│   │   │   │   ├── ActivationExplanationView.tsx
│   │   │   │   ├── AssemblyTable.tsx
│   │   │   │   ├── CCEChart.tsx
│   │   │   │   ├── DiagnosticAlerts.tsx
│   │   │   │   ├── LineageView.tsx
│   │   │   │   ├── MergeExplanationView.tsx
│   │   │   │   ├── MergeLogView.tsx
│   │   │   │   ├── MetricsChart.tsx
│   │   │   │   ├── OverviewCard.tsx
│   │   │   │   └── SystemArchitecture.tsx
│   │   │   ├── layout/         # Core layout components
│   │   │   │   ├── DashboardShell.tsx
│   │   │   │   ├── ServiceStatus.tsx
│   │   │   │   ├── Sidebar.tsx
│   │   │   │   └── TopBar.tsx
│   │   │   └── ui/             # Shadcn UI components (Button, Card, etc.)
│   │   │       ├── accordion.tsx
│   │   │       ├── ... (all shadcn components) ...
│   │   │       └── tooltip.tsx
│   │   ├── hooks/            # Custom React hooks
│   │   │   ├── use-mobile.tsx
│   │   │   └── use-toast.ts
│   │   ├── lib/              # Utilities and core logic
│   │   │   ├── api.ts          # TanStack Query hooks for API calls (NEEDS 5.9 UPDATES)
│   │   │   ├── queryClient.ts  # TanStack Query client configuration
│   │   │   ├── store.ts        # Zustand stores (polling, theme)
│   │   │   └── utils.ts        # Utility functions (e.g., cn)
│   │   ├── pages/            # Route components
│   │   │   ├── admin.tsx
│   │   │   ├── assemblies/
│   │   │   │   ├── index.tsx     # Assembly list view
│   │   │   │   └── [id].tsx      # Assembly detail/inspector view (OLD - replaced by assembly-inspector.tsx?)
│   │   │   ├── assembly-inspector.tsx # (NEW - Preferred name for detail view)
│   │   │   ├── cce.tsx
│   │   │   ├── chat.tsx        # Placeholder
│   │   │   ├── config.tsx
│   │   │   ├── logs.tsx        # Placeholder (could show merge log)
│   │   │   ├── llm-guidance.tsx
│   │   │   ├── memory-core.tsx
│   │   │   ├── neural-memory.tsx
│   │   │   ├── not-found.tsx
│   │   │   └── overview.tsx
│   │   ├── App.tsx             # Main application component with routing
│   │   ├── index.css           # Tailwind CSS base/styles
│   │   └── main.tsx            # Application entry point
│   ├── index.html          # Main HTML file
│   └── vite-env.d.ts       # Vite TypeScript definitions
├── server/                   # Express Backend Proxy Server
│   ├── index.ts            # Server entry point
│   ├── routes.ts           # API proxy route definitions (NEEDS 5.9 UPDATES)
│   ├── storage.ts          # In-memory storage for mocking (e.g., alerts)
│   ├── vite.ts             # Vite middleware integration helper
│   └── package.json        # Server dependencies
├── shared/                   # Shared TypeScript types/schemas
│   └── schema.ts           # Defines API data structures (NEEDS 5.9 UPDATES)
├── docs/                     # Project documentation (like this file)
│   └── dashboard/
├── attached_assets/          # (Potentially unused assets?)
├── .gitignore
├── .replit                   # Replit configuration
├── CONTRIBUTING.md
├── dev.ps1                   # Development start script (Windows PowerShell)
├── drizzle.config.ts         # Drizzle ORM config (may not be fully used yet)
├── generated-icon.png        # (Likely generated by Replit)
├── package.json              # Main project dependencies & scripts
├── postcss.config.js
├── README.md                 # Top-level project README
├── server.mjs                # Alternative/simplified server entry point?
├── start-dev.js              # Development start script (Node)
├── tailwind.config.ts
├── theme.json                # Shadcn theme config
└── tsconfig.json             # TypeScript configuration

Key Component Overview
DashboardShell: Provides the main layout including Sidebar and TopBar.

Sidebar: Contains navigation links defined via NavLink components. Uses wouter's useLocation to highlight the active link.

TopBar: Includes search (placeholder), refresh button, polling controls, and basic status indicators.

Page Components (pages/): Each corresponds to a route in App.tsx. They fetch data using hooks from lib/api.ts and render specific dashboard/ or ui/ components.

api.ts: Central place for defining useQuery hooks that interact with the dashboard's backend proxy API (/api/...). Needs functions/hooks for Phase 5.9 data.

routes.ts: Defines the Express routes on the dashboard's server. Needs proxy routes for Phase 5.9 backend endpoints.

schema.ts: Needs TypeScript interfaces matching the Pydantic models defined in docs/api/phase_5_9_models.md.

Explainability Components (dashboard/): ActivationExplanationView, MergeExplanationView, LineageView, MergeLogView are present but rely on data fetched via hooks in api.ts that need to target the (currently missing) proxy routes for Phase 5.9 endpoints.

---

## **4. `docs/dashboard/DATA_FLOW_API.md` (Data Flow & TODOs)**

```markdown
# Dashboard Data Flow & API Integration

This document explains how the Synthians Cognitive Dashboard fetches and displays data, highlighting the necessary steps to integrate Phase 5.9 backend features.

## Data Fetching Architecture

The dashboard uses a tiered approach for fetching data:

1.  **React Component:** A component (e.g., `pages/memory-core.tsx`) needs data.
2.  **TanStack Query Hook:** The component calls a custom hook from `client/src/lib/api.ts` (e.g., `useMemoryCoreStats()`).
3.  **`useQuery`:** This hook uses TanStack Query's `useQuery`. The `queryKey` typically represents the API path relative to the proxy (e.g., `['/api/memory-core/stats']`).
4.  **API Request:** `useQuery`'s `queryFn` (configured in `lib/queryClient.ts` or `lib/api.ts`) uses `axios` to make an HTTP request to the dashboard's **backend proxy server** (e.g., `GET http://localhost:5000/api/memory-core/stats`).
5.  **Proxy Forwarding:** The dashboard's Express server (`server/routes.ts`) intercepts the `/api/...` request. It identifies the target service (e.g., Memory Core) and forwards the request using `axios` to the actual service URL (e.g., `http://memory-core:5010/stats`).
6.  **Service Response:** The target Synthians service (e.g., Memory Core) processes the request and sends back JSON data.
7.  **Proxy Response:** The dashboard's Express server receives the response and forwards it back to the frontend client.
8.  **TanStack Query Cache:** TanStack Query receives the data, updates its cache, and makes the data available to the React component via the hook.
9.  **Component Render:** The React component re-renders with the fetched data, loading, or error state.

## Polling & Refreshing

*   **Polling:** The `usePollingStore` (Zustand) manages a global interval timer. On each tick, it calls `refreshAllData()` from `lib/api.ts`.
*   **`refreshAllData()`:** This function uses TanStack Query's `queryClient.invalidateQueries()` to mark relevant queries as stale, triggering background refetches for updated data.
*   **Manual Refresh:** The `<RefreshButton />` in the `TopBar` also calls `refreshAllData()`.

## API Proxy (`server/routes.ts`)

This is the **critical integration point** that bridges the frontend and the actual backend services.

**Current Status (Needs Update for 5.9):**

*   Proxies exist for basic health, status, and stats endpoints for MC, NM, CCE.
*   Proxies exist for listing/getting assemblies (`/api/memory-core/assemblies`).
*   Admin action proxies exist (verify index, set variant, etc.).
*   Mock `/api/alerts` endpoint exists.

**❗ Phase 5.9 TODOs - Add Proxy Routes in `server/routes.ts`:**

```typescript
// Example Structure (add these within registerRoutes in server/routes.ts)

// --- Memory Core Explainability Proxies ---
apiRouter.get("/memory-core/assemblies/:id/explain_activation", /* ... proxy to MC ... */ );
apiRouter.get("/memory-core/assemblies/:id/explain_merge",    /* ... proxy to MC ... */ );
apiRouter.get("/memory-core/assemblies/:id/lineage",         /* ... proxy to MC ... */ );

// --- Memory Core Diagnostics Proxies ---
apiRouter.get("/memory-core/diagnostics/merge_log",       /* ... proxy to MC (forward limit param) ... */ );
apiRouter.get("/memory-core/config/runtime/:service",   /* ... proxy to MC (use service param) ... */ );

// --- (Optional) Proxies for NM/CCE Runtime Config (if MC doesn't handle them) ---
// apiRouter.get("/neural-memory/config/runtime", /* ... proxy to NM or MC ... */ );
// apiRouter.get("/cce/config/runtime",           /* ... proxy to CCE or MC ... */ );

Ensure these proxy handlers correctly forward path parameters (:id, :service), query parameters (?memory_id=..., ?limit=...), and handle errors (forwarding status codes like 404, 403, 500).

API Client Hooks (client/src/lib/api.ts)
This file defines useQuery hooks for easy data fetching in components.

Current Status (Needs Update for 5.9):

Hooks exist for basic health, status, stats, assemblies.

❗ Phase 5.9 TODOs - Add useQuery Hooks in client/src/lib/api.ts:

// Example Structure (add these hooks to client/src/lib/api.ts)
import { /* Import necessary response types from @shared/schema */ } from '@shared/schema';

// --- Explainability Hooks ---
export const useExplainActivation = (assemblyId: string | null, memoryId?: string | null) => {
  return useQuery<ExplainActivationResponse>({ // Use correct response type
    queryKey: ['memory-core', 'assemblies', assemblyId, 'explain_activation', { memory_id: memoryId }],
    queryFn: defaultQueryFn, // Or custom fetcher
    enabled: !!assemblyId && !!memoryId, // Only enable when IDs are present
    retry: 1,
    staleTime: Infinity, // Data likely won't change unless manually triggered
  });
};

export const useExplainMerge = (assemblyId: string | null) => {
  return useQuery<ExplainMergeResponse>({ // Use correct response type
    queryKey: ['memory-core', 'assemblies', assemblyId, 'explain_merge'],
    queryFn: defaultQueryFn,
    enabled: !!assemblyId,
    retry: 1,
    staleTime: Infinity,
  });
};

export const useAssemblyLineage = (assemblyId: string | null) => {
  return useQuery<LineageResponse>({ // Use correct response type
    queryKey: ['memory-core', 'assemblies', assemblyId, 'lineage'],
    queryFn: defaultQueryFn,
    enabled: !!assemblyId,
    retry: 1,
    staleTime: Infinity,
  });
};

// --- Diagnostics Hooks ---
export const useMergeLog = (limit: number = 50) => {
  return useQuery<MergeLogResponse>({ // Use correct response type
    queryKey: ['memory-core', 'diagnostics', 'merge_log', { limit }],
    queryFn: defaultQueryFn,
    refetchInterval: 30000, // Optionally refetch merge log periodically
  });
};

export const useRuntimeConfig = (serviceName: string | null) => {
  return useQuery<RuntimeConfigResponse>({ // Use correct response type
    queryKey: ['memory-core', 'config', 'runtime', serviceName], // Assumes MC proxies all
    queryFn: defaultQueryFn,
    enabled: !!serviceName,
    staleTime: 5 * 60 * 1000, // Config changes less often, longer stale time
  });
};

// --- Update refreshAllData ---
// Add invalidations for new query keys like merge_log
// queryClient.invalidateQueries({ queryKey: ['memory-core', 'diagnostics', 'merge_log'] });
Use code with caution.
TypeScript
Ensure correct queryKey structures are used.

Use appropriate enabled flags (e.g., only fetch details when an ID is present, disable explain hooks by default until manually triggered).

Import and use the correct TypeScript response types from @shared/schema.ts.

Update refreshAllData to invalidate new queries if needed.

Shared Schema (shared/schema.ts)
❗ Phase 5.9 TODOs - Define TypeScript Interfaces:

Add interfaces matching the Pydantic models for all new API responses:

ExplainActivationResponse (containing ExplainActivationData)

ExplainMergeResponse (containing ExplainMergeData)

LineageResponse (containing LineageEntry[])

MergeLogResponse (containing MergeLogEntry[])

RuntimeConfigResponse (containing config: Record<string, any>)

Ensure existing types (Assembly, MemoryStats) are up-to-date if the backend changed them.