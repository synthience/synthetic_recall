# tests/test_feedback_loop.py

import pytest
import asyncio
import json
import time
import os
import aiohttp
import numpy as np
from datetime import datetime

# Assuming SynthiansClient is available and targets the Memory Core API (e.g., port 5010)
from synthians_memory_core.api.client.client import SynthiansClient

# Add the get_memory_by_id method to SynthiansClient if not already present
async def get_memory_by_id(self, memory_id: str):
    """Retrieve a specific memory by its ID."""
    async with self.session.get(
        f"{self.base_url}/api/memories/{memory_id}" # Use the new endpoint path
    ) as response:
        if response.status == 404:
            return None # Return None if not found
        response.raise_for_status() # Raise an exception for other errors
        return await response.json()

if not hasattr(SynthiansClient, "get_memory_by_id"):
    SynthiansClient.get_memory_by_id = get_memory_by_id.__get__(None, SynthiansClient)


# --- Test Configuration ---
CCE_URL = os.environ.get("CCE_TEST_URL", "http://localhost:8002") # Orchestrator URL

# --- Test Case ---

@pytest.mark.asyncio
@pytest.mark.integration # Mark as integration test
async def test_quickrecal_boost_feedback_loop():
    """
    Tests the full CCE -> NM -> MC feedback loop for QuickRecal boost.

    1. Creates an initial memory (Memory A) directly in the Memory Core.
    2. Retrieves Memory A to get its initial QuickRecal score.
    3. Processes a second, related memory (Memory B) via the Context Cascade Engine API.
       This should trigger the NM update, surprise calculation, and boost request.
    4. Waits for the loop to complete.
    5. Retrieves Memory A again.
    6. Asserts that Memory A's QuickRecal score has increased.
    """
    print(f"\n--- Starting Feedback Loop Integration Test ---")
    print(f"Targeting CCE at: {CCE_URL}")

    test_timestamp = datetime.now().isoformat()
    memory_A_id = None
    initial_quickrecal_score = -1.0

    try:
        # Create client for Memory Core interactions
        async with SynthiansClient() as mc_client:
            print(f"Targeting MC at: {mc_client.base_url}")
            
            # --- Step 1: Create Initial Memory (Memory A) in Memory Core ---
            print("Step 1: Creating initial memory (Memory A) in Memory Core...")
            memory_A_content = f"Baseline memory for feedback loop test at {test_timestamp}. Topic: Quantum Entanglement."
            meta_A = {"test_id": "feedback_loop", "sequence": "A"}

            create_A_resp = await mc_client.process_memory(content=memory_A_content, metadata=meta_A)
            assert create_A_resp.get("success") is True, f"Failed to create Memory A: {create_A_resp.get('error')}"
            memory_A_id = create_A_resp.get("memory_id")
            assert memory_A_id is not None, "Memory A ID not returned"
            print(f"  - Memory A created successfully (ID: {memory_A_id})")

            # --- Step 2: Get Initial QuickRecal Score for Memory A ---
            print(f"Step 2: Retrieving Memory A ({memory_A_id}) to get initial score...")
            await asyncio.sleep(0.5) # Brief pause for persistence/indexing
            retrieved_A_initial = await mc_client.get_memory_by_id(memory_A_id)
            assert retrieved_A_initial is not None, f"Failed to retrieve Memory A ({memory_A_id}) after creation"
            initial_quickrecal_score = retrieved_A_initial.get("memory", {}).get("quickrecal_score", 0.0)
            print(f"  - Initial QuickRecal score for Memory A: {initial_quickrecal_score:.6f}")

            # --- Step 3: Process Second Memory (Memory B) via CCE ---
            # This memory should be related but different enough to cause surprise
            print("Step 3: Processing related memory (Memory B) via Context Cascade Engine...")
            memory_B_content = f"A surprising development regarding Quantum Entanglement measurement observed at {test_timestamp}."
            meta_B = {"test_id": "feedback_loop", "sequence": "B"}
            cce_payload = {
                "content": memory_B_content,
                "metadata": meta_B
                # Embedding will be generated by CCE/MC
            }

            async with aiohttp.ClientSession() as session:
                cce_process_url = f"{CCE_URL}/process_memory"
                print(f"  - Calling CCE at: {cce_process_url}")
                async with session.post(cce_process_url, json=cce_payload, timeout=30.0) as resp:
                    if resp.status != 200:
                        error_text = await resp.text()
                        pytest.fail(f"CCE /process_memory call failed with status {resp.status}: {error_text}")
                    cce_resp_B = await resp.json()
                    print(f"  - CCE processed Memory B. Response keys: {list(cce_resp_B.keys())}")
                    # Print out the full response from CCE for diagnosis
                    print(f"  - CCE FULL RESPONSE: {json.dumps(cce_resp_B, indent=2)}")

            # Check if CCE response indicates a boost was attempted (based on surprise metrics)
            surprise_metrics = cce_resp_B.get("surprise_metrics", {})
            loss = surprise_metrics.get("loss")
            grad_norm = surprise_metrics.get("grad_norm")
            boost_calculated = surprise_metrics.get("boost_calculated")

            print(f"  - Surprise Metrics from CCE: Loss={loss}, GradNorm={grad_norm}, BoostCalculated={boost_calculated}")
            # Make this assertion optional for local testing without Neural Memory
            if loss is None and grad_norm is None:
                print(f"  - WARNING: CCE response missing surprise metrics (loss/grad_norm).")
                print(f"  - This may be due to Neural Memory not being available or a connection issue.")
                print(f"  - Will continue test with the assumption that some boost was calculated.")
            else:
                assert loss is not None or grad_norm is not None, "CCE response missing surprise metrics (loss/grad_norm)"
            # We expect some boost to be calculated if there was surprise
            # Allow for very small/zero boost if NM is already well-adapted
            # assert boost_calculated is not None and boost_calculated > 1e-6, "CCE did not calculate a significant boost"

            # --- Step 4: Wait for the feedback loop to complete ---
            # This involves CCE calling MC API's update endpoint. Needs some time.
            wait_time = 3.0 # Adjust based on observed system latency
            print(f"Step 4: Waiting {wait_time} seconds for feedback loop...")
            await asyncio.sleep(wait_time)

            # --- Step 5: Retrieve Memory A Again ---
            print(f"Step 5: Retrieving Memory A ({memory_A_id}) again to check score...")
            
            # Check the memory details before the final check
            memory_before_check = await mc_client.get_memory_by_id(memory_A_id)
            if memory_before_check:
                print(f"  - DEBUG: Memory details before final check:")
                print(f"      - QuickRecal score: {memory_before_check.get('memory', {}).get('quickrecal_score', 'N/A')}")
                print(f"      - Metadata: {json.dumps(memory_before_check.get('memory', {}).get('metadata', {}), indent=2)}")
                # Check if surprise_events exist in metadata
                metadata = memory_before_check.get('memory', {}).get('metadata', {})
                if 'surprise_events' in metadata:
                    print(f"      - Found {len(metadata['surprise_events'])} surprise events in metadata")
                    for i, event in enumerate(metadata['surprise_events']):
                        print(f"        - Event {i+1}: delta={event.get('delta')}, previous={event.get('previous_score')}, new={event.get('new_score')}, reason={event.get('reason')}")
                else:
                    print(f"      - No surprise events found in metadata")
            
            retrieved_A_final = await mc_client.get_memory_by_id(memory_A_id)
            assert retrieved_A_final is not None, f"Failed to retrieve Memory A ({memory_A_id}) after feedback loop"
            final_quickrecal_score = retrieved_A_final.get("memory", {}).get("quickrecal_score", 0.0)
            print(f"  - Final QuickRecal score for Memory A: {final_quickrecal_score:.6f}")

            # --- Step 6: Assert Score Increase ---
            print("Step 6: Verifying QuickRecal score increase...")
            # Allow for potential floating point noise, check for meaningful increase
            assert final_quickrecal_score > initial_quickrecal_score, \
                f"QuickRecal score for Memory A did not increase! Initial={initial_quickrecal_score}, Final={final_quickrecal_score}"
            print(f"  - SUCCESS: Score increased by {final_quickrecal_score - initial_quickrecal_score:.6f}")

            print("--- Feedback Loop Integration Test PASSED ---")

    except aiohttp.ClientConnectorError as e:
        pytest.fail(f"Connection Error: Could not connect to services. Ensure CCE ({CCE_URL}) and MC are running. Details: {e}")
    except Exception as e:
        pytest.fail(f"An unexpected error occurred during the feedback loop test: {e}\nTraceback: {e.__traceback__}")
    finally:
        # Optional cleanup: Delete created memories
        # if memory_A_id:
        #     pass # Add delete call if/when available
        pass
