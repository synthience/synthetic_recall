## 🧠📄 Synthians Cognitive System Cheat Sheet — *Phase 5.8 (Stabilized & Drift-Aware)*

> *"The blueprint remembers. The associator adapts. The cascade organizes. Now the archive stabilizes, traces, and tells its own recovery story."*

---

### 🏛️ MEMORY CORE (MC) — *The Archive*

#### 🧰 Role
Persistent, indexed memory layer for contextual recall. Supports **QuickRecal scoring**, emotional filtering, **Memory Assembly activation boosting**, and **embedding drift detection**.

#### 📦 Key Components
- `SynthiansMemoryCore`, `MemoryPersistence`, `MemoryVectorIndex` (FAISS)
- `UnifiedQuickRecallCalculator`, `GeometryManager`, `EmotionAnalyzer`
- `MetadataSynthesizer`, `ThresholdCalibrator`

---

#### 🧱 Memory Structures
##### `MemoryEntry`
- Core unit: `content`, `embedding`, `metadata`, `quick_recal_score`
- Embeddings **validated for NaN/Inf**. Normalized.

##### `MemoryAssembly`
- Group of related `MemoryEntry` IDs.
- Fields: `composite_embedding`, `hyperbolic_embedding`, `activation_count`, `last_activation`, `vector_index_updated_at`, `tags`, `topics`, `assembly_schema_version`
- Maintains a **timestamped index sync trace** via `vector_index_updated_at`
- Lifecycle-enabled (`active`, `merged_from`, `created_at`, `updated_at`)

---

#### 🔁 Indexing + Boosting
- **Composite embeddings** stored in FAISS with ID prefix `"asm:"`
- Activated via `_activate_assemblies()` if aligned similarity ≥ `activation_threshold`
- Boost applied per `assembly_boost_mode` + `assembly_boost_factor`, gated by:
  - Drift check: `now() - vector_index_updated_at < MAX_ALLOWED_DRIFT`
  - Alignment result must not be `None`
- Final `relevance_score` = similarity + boost (clamped ≤ 1.0)

---

#### 💾 Persistence
- All entries + assemblies saved via `MemoryPersistence` (async JSON)
- Vector index persisted as:
  - `.bin` (FAISS structure)
  - `.mapping.json` (ID↔vector ID map)
- Assemblies: Saved in `assemblies/` folder per ID

---

#### 🔍 Retrieval Pipeline
1. `retrieve_memories(query_embedding)`
2. `_activate_assemblies(query_embedding)`
3. `_get_candidate_memories()` collects direct and assembly-linked memory IDs
4. Apply relevance boost from assemblies
5. **Apply filters:** Gating, metadata
6. **Sort by `relevance_score`**
7. Return `top_k`

---

#### 📊 Diagnostics & Observability
- `/stats` includes:
  - FAISS vector count, mapping count, **vector index pending updates**
  - Assembly activation stats: counts, sizes, boost logs
- `/assemblies`, `/assemblies/{id}` expose:
  - `tags`, `topics`, `activation_count`, `drift_seconds`
- **Recovery Timeline (experimental):**
  - Exposes lifecycle of memory/assembly updates
  - API under `/assemblies/{id}/timeline`
- Logs:
  - `[VECTOR_TRACE]` includes `faiss_index.ntotal` and mapping delta
  - Activation boost logs show contribution per memory

---

### 🧠 NEURAL MEMORY (NM) — *The Associator*

#### 🧰 Role
Test-time-updatable vector memory (`k → v`) via momentum update. No structural changes in Phase 5.8.

#### 🧪 Components
- `NeuralMemoryModule` (TF/Keras), `MemoryMLP`
- Tracks `loss`, `grad_norm`, `performance_history`

#### 🔄 API (Unchanged)
- `POST /update_memory`
- `POST /retrieve`
- `GET /get_projections`, `calculate_gates`, `diagnose_emoloop`

---

### ⚙️ Context Cascade Engine (CCE) — *The Orchestrator*

#### 🧰 Role
Manages cognitive loop, memory selection, variant execution, and LLM advice routing.

#### 🔄 Phase 5.8 Behavior
- Delegates retrieval to MC (now with assembly boost)
- Records `activation_hints` and memory context
- Optionally uses LLM summaries to **boost QR scores** via:
  - `POST /api/memories/update_quickrecal_score`

---

### ✨ PHASE 5.8 HIGHLIGHTS

| Feature | Description |
|--------|-------------|
| ✅ **Assembly Boosting** | Related memories boosted via activated assemblies |
| ✅ **Embedding Drift Awareness** | Uses `vector_index_updated_at` to ensure alignment freshness |
| ✅ **Repair-Resilient Retrieval** | Index is now **verified post-load**, with diagnostics and auto-repair paths |
| ✅ **Diagnostics Dashboard** | `/stats`, `/assemblies`, retry queue, and boost logs all surfaced |
| ✅ **Lifecycle Control** | Pruning, merging via background loop with config flags |
| ✅ **Fail-Resilient Index Add/Update** | Retry buffer + sync fallback with `/stats` visibility |
| ✅ **Schema Migration Ready** | `assembly_schema_version` supports upgrade flow via `from_dict()` |

---

### ⚙️ Configuration Flags

- `enable_assembly_pruning = True/False`
- `enable_assembly_merging = True/False`
- `assembly_activation_threshold = float`
- `assembly_boost_mode = linear|sigmoid`
- `assembly_boost_factor = float`
- `max_allowed_drift_seconds = int`

---

### 🧠 Pro Tips

- **Drift > threshold?** Skip boost. Log desync.
- **Assembly not indexed?** Check `vector_index_updated_at` = None.
- **Empty results?** Check `/stats` for FAISS vector count vs mapping.
- **Repair Needed?** Trigger `/repair_index` manually or verify load-time auto repair fired.

---

### 📡 Upcoming Phase 5.9 Anchors (Interpretability & Summarization)

- `MemoryAssembly.semantic_version_id`
- Composite drift diffs
- LLM-aware summarization of active assemblies
- Timeline-based memory mutation tracing

---

### 🔒 Stability Check Summary

| System Checkpoint | Validation |
|------------------|------------|
| Embedding Shape & NaN | ✅ `validate_embedding()` + `safe_normalize()` |
| Index ↔ Mapping Sync | ✅ `verify_index_integrity()` + `.ntotal == len(mapping)` |
| Retry Queue Health | ✅ `/stats["vector_index_pending_updates"]` |
| Assembly Activation Drift | ✅ `now - vector_index_updated_at < threshold` |
| Repair Endpoint | ✅ `/repair_index` (manual fallback) |
| Timeline View | ✅ `/assemblies/{id}/timeline` (optional dev mode) |

---

### 🧬 Final Thought

> **Stability is not just code—it’s behavioral memory.**  
> Every retrieval is a story made whole by coordination, visibility, and trust in drift-aware recovery.

---
